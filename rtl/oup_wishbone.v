//////////////////////////////////////////////////////////////////////////////////////
// Title          : Wishbone slave core for GPIO Port
//////////////////////////////////////////////////////////////////////////////////////
// File           : rtl/oup_wishbone.v
// Author         : auto-generated by wbgen2 from oup_wbgen2.wb
// Created        : Mon Jan  1 12:03:32 2024
// Standard       : Verilog 2001
//////////////////////////////////////////////////////////////////////////////////////
// THIS FILE WAS GENERATED BY wbgen2 FROM SOURCE FILE oup_wbgen2.wb
// DO NOT HAND-EDIT UNLESS IT'S ABSOLUTELY NECESSARY!
//////////////////////////////////////////////////////////////////////////////////////

module wb_slave_gpio_port (
// 
  input              rst_n_i,
// 
  input              clk_sys_i,
// 
  input       [2:0]  wb_adr_i,
// 
  input       [31:0] wb_dat_i,
// 
  output      [31:0] wb_dat_o,
// 
  input              wb_cyc_i,
// 
  input       [3:0]  wb_sel_i,
// 
  input              wb_stb_i,
// 
  input              wb_we_i,
// 
  output             wb_ack_o,
// 
  output             wb_err_o,
// 
  output             wb_rty_o,
// 
  output             wb_stall_o,
// Port for std_logic_vector field: 'Pin directions' in reg: 'Pin direction register'
  output      [31:0] gpio_ddr_o,
// Port for std_logic_vector field: 'Pin input state' in reg: 'Pin input state register'
  input       [31:0] gpio_psr_i,
// Ports for PASS_THROUGH field: 'Port output value' in reg: 'Port output register'
  output      [31:0] gpio_pdr_o,
  output reg         gpio_pdr_wr_o,
// Ports for PASS_THROUGH field: 'Set output pin register' in reg: 'Set output pin register'
  output      [31:0] gpio_sopr_o,
  output reg         gpio_sopr_wr_o,
// Ports for PASS_THROUGH field: 'Clear output pin register' in reg: 'Clear output pin register'
  output      [31:0] gpio_copr_o,
  output reg         gpio_copr_wr_o
);

reg   [31:0]  gpio_ddr_int;
reg   [9:0]   ack_sreg;
reg   [31:0]  rddata_reg;
wire  [31:0]  wrdata_reg;
wire  [3:0]   bwsel_reg;
wire  [2:0]   rwaddr_reg;
reg           ack_in_progress;
wire          wr_int;
wire          rd_int;
wire  [31:0]  allones;
wire  [31:0]  allzeros;

// Some internal signals assignments
assign wrdata_reg = wb_dat_i;
// 
// Main register bank access process.
always @(posedge clk_sys_i or negedge rst_n_i) begin
  if (rst_n_i == 1'b0) begin 
    ack_sreg <= 0;
    ack_in_progress <= 0;
    rddata_reg <= 0;
    gpio_ddr_int <= 0;
    gpio_pdr_wr_o <= 0;
    gpio_sopr_wr_o <= 0;
    gpio_copr_wr_o <= 0;
  end else begin
// advance the ACK generator shift register
    ack_sreg[8:0] <= ack_sreg[9:1];
    ack_sreg[9] <= 0;
    if (ack_in_progress == 1) begin
      if (ack_sreg[0] == 1) begin
        gpio_pdr_wr_o <= 0;
        gpio_sopr_wr_o <= 0;
        gpio_copr_wr_o <= 0;
        ack_in_progress <= 0;
      end else begin
        gpio_pdr_wr_o <= 0;
        gpio_sopr_wr_o <= 0;
        gpio_copr_wr_o <= 0;
      end
    end else begin
      if ((wb_cyc_i == 1) && (wb_stb_i == 1)) begin
        case (rwaddr_reg[2:0])        
        3'h0: begin
          if (wb_we_i == 1) begin
            gpio_ddr_int <= wrdata_reg[31:0];
          end
          rddata_reg[31:0] <= gpio_ddr_int;
          ack_sreg[0] <= 1;
          ack_in_progress <= 1;
        end
        3'h1: begin
          if (wb_we_i == 1) begin
          end
          rddata_reg[31:0] <= gpio_psr_i;
          ack_sreg[0] <= 1;
          ack_in_progress <= 1;
        end
        3'h2: begin
          if (wb_we_i == 1) begin
            gpio_pdr_wr_o <= 1;
          end
          rddata_reg[0] <= 1'bX;
          rddata_reg[1] <= 1'bX;
          rddata_reg[2] <= 1'bX;
          rddata_reg[3] <= 1'bX;
          rddata_reg[4] <= 1'bX;
          rddata_reg[5] <= 1'bX;
          rddata_reg[6] <= 1'bX;
          rddata_reg[7] <= 1'bX;
          rddata_reg[8] <= 1'bX;
          rddata_reg[9] <= 1'bX;
          rddata_reg[10] <= 1'bX;
          rddata_reg[11] <= 1'bX;
          rddata_reg[12] <= 1'bX;
          rddata_reg[13] <= 1'bX;
          rddata_reg[14] <= 1'bX;
          rddata_reg[15] <= 1'bX;
          rddata_reg[16] <= 1'bX;
          rddata_reg[17] <= 1'bX;
          rddata_reg[18] <= 1'bX;
          rddata_reg[19] <= 1'bX;
          rddata_reg[20] <= 1'bX;
          rddata_reg[21] <= 1'bX;
          rddata_reg[22] <= 1'bX;
          rddata_reg[23] <= 1'bX;
          rddata_reg[24] <= 1'bX;
          rddata_reg[25] <= 1'bX;
          rddata_reg[26] <= 1'bX;
          rddata_reg[27] <= 1'bX;
          rddata_reg[28] <= 1'bX;
          rddata_reg[29] <= 1'bX;
          rddata_reg[30] <= 1'bX;
          rddata_reg[31] <= 1'bX;
          ack_sreg[0] <= 1;
          ack_in_progress <= 1;
        end
        3'h4: begin
          if (wb_we_i == 1) begin
            gpio_sopr_wr_o <= 1;
          end
          rddata_reg[0] <= 1'bX;
          rddata_reg[1] <= 1'bX;
          rddata_reg[2] <= 1'bX;
          rddata_reg[3] <= 1'bX;
          rddata_reg[4] <= 1'bX;
          rddata_reg[5] <= 1'bX;
          rddata_reg[6] <= 1'bX;
          rddata_reg[7] <= 1'bX;
          rddata_reg[8] <= 1'bX;
          rddata_reg[9] <= 1'bX;
          rddata_reg[10] <= 1'bX;
          rddata_reg[11] <= 1'bX;
          rddata_reg[12] <= 1'bX;
          rddata_reg[13] <= 1'bX;
          rddata_reg[14] <= 1'bX;
          rddata_reg[15] <= 1'bX;
          rddata_reg[16] <= 1'bX;
          rddata_reg[17] <= 1'bX;
          rddata_reg[18] <= 1'bX;
          rddata_reg[19] <= 1'bX;
          rddata_reg[20] <= 1'bX;
          rddata_reg[21] <= 1'bX;
          rddata_reg[22] <= 1'bX;
          rddata_reg[23] <= 1'bX;
          rddata_reg[24] <= 1'bX;
          rddata_reg[25] <= 1'bX;
          rddata_reg[26] <= 1'bX;
          rddata_reg[27] <= 1'bX;
          rddata_reg[28] <= 1'bX;
          rddata_reg[29] <= 1'bX;
          rddata_reg[30] <= 1'bX;
          rddata_reg[31] <= 1'bX;
          ack_sreg[0] <= 1;
          ack_in_progress <= 1;
        end
        3'h5: begin
          if (wb_we_i == 1) begin
            gpio_copr_wr_o <= 1;
          end
          rddata_reg[0] <= 1'bX;
          rddata_reg[1] <= 1'bX;
          rddata_reg[2] <= 1'bX;
          rddata_reg[3] <= 1'bX;
          rddata_reg[4] <= 1'bX;
          rddata_reg[5] <= 1'bX;
          rddata_reg[6] <= 1'bX;
          rddata_reg[7] <= 1'bX;
          rddata_reg[8] <= 1'bX;
          rddata_reg[9] <= 1'bX;
          rddata_reg[10] <= 1'bX;
          rddata_reg[11] <= 1'bX;
          rddata_reg[12] <= 1'bX;
          rddata_reg[13] <= 1'bX;
          rddata_reg[14] <= 1'bX;
          rddata_reg[15] <= 1'bX;
          rddata_reg[16] <= 1'bX;
          rddata_reg[17] <= 1'bX;
          rddata_reg[18] <= 1'bX;
          rddata_reg[19] <= 1'bX;
          rddata_reg[20] <= 1'bX;
          rddata_reg[21] <= 1'bX;
          rddata_reg[22] <= 1'bX;
          rddata_reg[23] <= 1'bX;
          rddata_reg[24] <= 1'bX;
          rddata_reg[25] <= 1'bX;
          rddata_reg[26] <= 1'bX;
          rddata_reg[27] <= 1'bX;
          rddata_reg[28] <= 1'bX;
          rddata_reg[29] <= 1'bX;
          rddata_reg[30] <= 1'bX;
          rddata_reg[31] <= 1'bX;
          ack_sreg[0] <= 1;
          ack_in_progress <= 1;
        end
        default: begin
// prevent the slave from hanging the bus on invalid address
          ack_in_progress <= 1;
          ack_sreg[0] <= 1;
        end
        endcase
      end
    end
  end
end

// Drive the data output bus
assign wb_dat_o = rddata_reg;
// Pin directions
assign gpio_ddr_o = gpio_ddr_int;
// Pin input state
// Port output value
// pass-through field: Port output value in register: Port output register
assign gpio_pdr_o = wrdata_reg[31:0];
// Set output pin register
// pass-through field: Set output pin register in register: Set output pin register
assign gpio_sopr_o = wrdata_reg[31:0];
// Clear output pin register
// pass-through field: Clear output pin register in register: Clear output pin register
assign gpio_copr_o = wrdata_reg[31:0];
assign rwaddr_reg = wb_adr_i;
assign wb_stall_o = (! ack_sreg[0]) && (wb_stb_i && wb_cyc_i);
assign wb_err_o = 0;
assign wb_rty_o = 0;
// ACK signal generation. Just pass the LSB of ACK counter.
assign wb_ack_o = ack_sreg[0];
endmodule
